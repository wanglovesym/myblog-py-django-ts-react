# ============================================================
# Docker Compose - 生产环境（完整版）
# 包含：反向代理、前端静态、后端 API、PostgreSQL 数据库
# ============================================================
# 架构说明：
# - proxy（Nginx）：统一入口，处理所有外部请求（HTTP/将来 HTTPS）
# - frontend（Nginx 静态）：React 打包后的静态文件（HTML/CSS/JS）
# - backend（Gunicorn）：Django API 服务器
# - db（PostgreSQL）：生产数据库，数据持久化到卷
# ============================================================

services:
    # ========== 数据库服务（PostgreSQL） ==========
    db:
        image: postgres:16 # 使用官方 Postgres 16 镜像（稳定版）
        container_name: myblog-db-prod
        # 共享同一生产 env 文件，避免密码不一致
        env_file:
            - .env.prod
        environment:
            POSTGRES_DB: myblog
            POSTGRES_USER: myblog

        # 卷挂载：持久化数据库数据
        volumes:
            - pg_data_prod:/var/lib/postgresql/data # 数据文件
            # 可选：挂载备份脚本或初始化 SQL
            # - ./deploy/init.sql:/docker-entrypoint-initdb.d/init.sql:ro

        # 不对外暴露端口（仅容器间通信）
        # ports:
        #   - "5432:5432"                         # ❌ 生产不要暴露数据库到公网
        expose:
            - "5432" # ✅ 仅暴露给同网络的服务

        networks:
            - app_net # 加入内部网络

        # 健康检查：确保数据库就绪后才启动依赖服务
        healthcheck:
            test: ["CMD-SHELL", "pg_isready -U myblog -d myblog"]
            interval: 10s
            timeout: 5s
            retries: 5
            start_period: 30s # 启动后 30 秒内允许失败（初始化窗口）

        # 重启策略：容器异常退出时自动重启（生产必备）
        restart: unless-stopped

    # ========== 后端服务（Django + Gunicorn） ==========
    backend:
        build:
            context: ./myblog-backend-django # 使用后端目录作为构建上下文
            dockerfile: Dockerfile # 默认 Dockerfile（含 Gunicorn CMD）
            args:
                # 默认版本占位符，实际构建由 manage_prod.sh 通过 --build-arg 覆盖
                APP_VERSION: "unknown"

        container_name: myblog-backend-prod

        # 环境变量文件（生产配置）
        env_file:
            - .env.prod # 包含 DEBUG=0、SECRET_KEY、数据库连接等

        # 不对外暴露端口（仅供 proxy 内网访问）
        expose:
            - "8000" # ✅ Gunicorn 监听 8000

        networks:
            - app_net

        # 依赖：等待数据库健康检查通过后再启动
        depends_on:
            db:
                condition: service_healthy # 确保数据库就绪

        # 健康检查:通过访问应用 /api/health/ 验证 HTTP 与数据库链路
        healthcheck:
            test:
                [
                    "CMD-SHELL",
                    "curl -fsS -H 'Host: api.wangshixin.me' http://localhost:8000/api/health/ || exit 1"
                ]
            interval: 15s
            timeout: 5s
            retries: 5
            start_period: 40s

        restart: unless-stopped

        # 挂载静态文件卷：用于 Django collectstatic 结果共享给 proxy 提供 /static/
        volumes:
            - static_files:/app/staticfiles # STATIC_ROOT 实际路径
            - ./myblog-backend-django/media:/app/media # MEDIA_ROOT 用户上传文件（bind mount）

    # ========== 前端服务（Nginx 静态站） ==========
    frontend:
        build:
            context: ./myblog-frontend-react # 使用前端目录作为构建上下文
            dockerfile: Dockerfile # 生产 Dockerfile（Node 构建 → Nginx 提供）
            args:
                # 从 .env.prod.frontend 或环境变量读取 API 地址
                VITE_API_BASE_URL: ${VITE_API_BASE_URL:-https://api.wangshixin.me}

        container_name: myblog-frontend-prod

        expose:
            - "80" # ✅ Nginx 在容器内部监听 80

        networks:
            - app_net

        restart: unless-stopped

    # ========== 反向代理（统一入口） ==========
    proxy:
        image: nginx:1.27-alpine # 轻量 Nginx 镜像
        container_name: myblog-proxy

        # 对外公开端口
        ports:
            - "80:80" # HTTP 入口
            - "443:443" # HTTPS 入口

        # 挂载自定义配置
        volumes:
            - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro # 全局配置
            - ./nginx/conf.d:/etc/nginx/conf.d:ro # 站点配置
            - ./nginx/ssl:/etc/nginx/ssl:ro # SSL 证书
            - static_files:/app/staticfiles:ro # Django 静态文件
            - ./myblog-backend-django/media:/app/media:ro # 用户上传文件（bind mount）
            - /var/www/certbot:/var/www/certbot # ACME 验证

        # 依赖：等待前后端服务就绪
        depends_on:
            - backend
            - frontend

        networks:
            - app_net

        restart: unless-stopped

# ============================================================
# 网络定义
# ============================================================
networks:
    app_net:
        driver: bridge # 默认桥接网络（容器间可互访）
        # 生产可选：使用 overlay 网络（跨主机 Swarm/K8s）

# ============================================================
# 卷定义（持久化数据）
# ============================================================
volumes:
    pg_data_prod:
        # 默认存储在 /var/lib/docker/volumes/
        # 可选：指定驱动或外部卷（如 NFS、云存储）
        # driver: local
        # driver_opts:
        #   type: nfs
        #   o: addr=192.168.1.100,rw
        #   device: ":/path/to/nfs/share"

    # 静态文件卷（Django collectstatic 输出）
    static_files:

    # 媒体文件使用 bind mount（见 backend 和 proxy 配置）
    # 路径: ./myblog-backend-django/media:/app/media
